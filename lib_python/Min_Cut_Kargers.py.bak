# A continuacion el algoritmo de corte minimo
# dado un grafo

# La implementacion de este algoritmo fue desarrollada por Raul Bernardo
# Rodas Herrera, el 20 de Septiembre del ano 2013.

# Se importan las librerias correspondientes
# Libreria para el manejo de grafos.
# Para obtener valores aleatorios
import random


#################################################
# Esta funcion modifica el grafo dado un par de nodos para contraer
def contraer(grafo, nodo_1, nodo_2):

    # Nodos unidos:	En esta parte lo que se hace es ordenar el string
    # que contiene los nodos que estan unidos
    nuevo_nodo = "%s,%s" % (nodo_1, nodo_2)
    nuevo_nodo = sorted([int(i) for i in nuevo_nodo.split(',')])
    nuevo_nodo = ','.join(str(i) for i in nuevo_nodo)
    # Listado de nodos que se mantienen y que se unen
    nodos = grafo.nodes()
    nodos_mantienen = [i for i in nodos if (i != nodo_1 and i != nodo_2)]
    # Se crea el grafo contraido, vacio
    contraccion = grafo.subgraph(nodos_mantienen)

    # Se agrega el nodo que se merge/unio
    contraccion.add_node(nuevo_nodo)

    # Se agregan los arcos con peso, del nuevo nodo
    # Esta parte genera un listado con las distancias de los nodos que se
    # unieron.
    iterador = grafo.edges_iter(nbunch=[nodo_1, nodo_2], data="weight")
    lista_agregar = [(i[0], i[1], i[2]['weight'])
                     for i in iterador
                     if ([i[0], i[1]] != [nodo_1, nodo_2]
                         and [i[1], i[0]] != [nodo_1, nodo_2])]

    # Aqui se remplazan los nombres
    lista_agregar = [(nuevo_nodo, tupla[1], tupla[2])
                     if (tupla[0] == nodo_1 or tupla[0] == nodo_2)
                     else (tupla[0], nuevo_nodo, tupla[2])
                     for tupla in lista_agregar]

    # Finalmente se agrega la lista
    contraccion.add_weighted_edges_from(lista_agregar)

    # Se retorna el grafico contraido
    return contraccion


#################################################
# Aqui se define la funcion que genera un grafo contraido
def contraer_hasta_2_nodos(grafo):

    # Se estima este parametro, el cual es condicion de detencion
    num_vertices_grafo = len(grafo.nodes())

    # Mientras la cantidad de vertices sea mayor estricto que 2, procede:
    while num_vertices_grafo > 2:

        # Elije cualquiera de los arcos al azar.
        elem_rand = random.choice(list(set(grafo.edges())))
        indice_arco_azar = grafo.edges().index(elem_rand)

        nodo_1 = grafo.edges()[indice_arco_azar][0]
        nodo_2 = grafo.edges()[indice_arco_azar][1]

        # Contrae en UN SOLO nodo los nodos del vertice elegido.
        # Recordar que esto actualiza el grafo
        grafo = contraer(grafo, nodo_1, nodo_2)

        # Se estima este parametro, el cual es condicion de detencion
        num_vertices_grafo = len(grafo.nodes())

    # Retorna el grafo final
    return grafo


#################################################
# Aqui se define la funcion, recordar que G,
# es una instancia "grafo" del tipo "networkX"
def min_cut(grafo, num_iteraciones=1000):

    # Suma del corte inicial, esto es infinito
    suma_corte_minimo = 9999999999999999

    ### ESTE FOR ES PARALELIZABLE ###
    # Numero de iteraciones buscando el valor minimo
    for iteracion in range(num_iteraciones):

        # Se contrae el grafo
        resultado = contraer_hasta_2_nodos(grafo)

        # Suma del MultiGrafo resultante.
        iterador = resultado.edges_iter(data="weight")
        suma_corte = sum([i[2]["weight"] for i in iterador])

        # Si se supera el valor anterior
        if suma_corte < suma_corte_minimo:
            # Suma del corte
            suma_corte_minimo = suma_corte
            # Se guarda el mejor grafo hasta el minuto
            grafo_final = resultado

            print(" iteracion %s" % (iteracion))
            print("suma corte %s" % (suma_corte_minimo))
            print("nodos %s" % (grafo_final.nodes()))
            print("\n")

    return grafo_final, suma_corte_minimo
